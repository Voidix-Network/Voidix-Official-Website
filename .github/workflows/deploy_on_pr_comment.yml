name: Advanced PR Deployment Controller

on:
  issue_comment:
    types: [created]
  pull_request_target: # ä½¿ç”¨ pull_request_target ä»¥å®‰å…¨åœ°å¤„ç†æ ‡ç­¾å’Œè·å– PR è¯¦æƒ…
    types: [closed]

permissions:
  contents: read
  issues: write       # ç”¨äºè¯„è®º
  pull-requests: write # ç”¨äºæ·»åŠ /ç§»é™¤æ ‡ç­¾

jobs:
  # Job 1: å¤„ç† 'deploy' è¯„è®º
  handle_deploy_comment:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, 'deploy')
    runs-on: [self-hosted, website]
    outputs:
      should_deploy_immediately: ${{ steps.check_pr_status.outputs.deploy_now }}
      pr_number_for_immediate_deploy: ${{ steps.check_pr_status.outputs.pr_number }}
      commenter_login: ${{ steps.check_permissions.outputs.commenter }}
      # comment_id_for_immediate_deploy: ${{ steps.check_pr_status.outputs.comment_id }} # Potentially pass comment_id

    steps:
      - name: Check Commenter Permissions
        id: check_permissions
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const authorizedAssociations = ['OWNER', 'MEMBER'];
            const authorAssociation = context.payload.comment.author_association;
            const commenter = context.payload.comment.user.login;
            core.setOutput('commenter', commenter);

            if (!authorizedAssociations.includes(authorAssociation)) {
              // å¯¹äºæƒé™é”™è¯¯ï¼Œæ€»æ˜¯å‘é€æ–°è¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `âŒ @${commenter}, æ‚¨æ²¡æœ‰è¶³å¤Ÿçš„æƒé™ (éœ€è¦ OWNER æˆ– MEMBER) æ¥è§¦å‘éƒ¨ç½²ã€‚æ‚¨å½“å‰çš„å…³è”æ˜¯ï¼š${authorAssociation}ã€‚`
              });
              core.setFailed(`è¯„è®ºè€… @${commenter} (${authorAssociation}) æ— æƒæ“ä½œã€‚`);
              return;
            }
            console.log(`æˆæƒè¯„è®ºè€…: @${commenter} (${authorAssociation})`);

      - name: Get PR Details & Decide Action
        id: check_pr_status
        if: steps.check_permissions.outcome == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string # Ensure outputs are strings
          script: |
            const prNumber = context.issue.number;
            core.setOutput('pr_number', prNumber.toString());
            const commenter = '${{ steps.check_permissions.outputs.commenter }}';
            const marker = `<!-- GHA-DEPLOY-STATUS-PR#${prNumber} -->`;
            const workflowRunUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            async function findAndUpdateOrCreateComment(github, context, issueNumber, marker, newBody, workflowLinkText) {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });
              const existingComment = comments.find(comment => comment.body && comment.body.includes(marker));
              
              let finalBody = newBody;
              if (workflowLinkText) {
                finalBody += `\n[${workflowLinkText}](${workflowRunUrl})`;
              }
              finalBody += `\n\n${marker}`; // Ensure marker persists

              if (existingComment) {
                console.log(`Found existing comment ${existingComment.id} to update for PR #${issueNumber}.`);
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: finalBody,
                });
                return existingComment.id.toString();
              } else {
                console.log(`No existing comment found with marker for PR #${issueNumber}. Creating new one.`);
                const { data: newComment } = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: finalBody,
                });
                return newComment.id.toString();
              }
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            if (pr.base.ref !== 'master') {
              // å¯¹äºé master ç›®æ ‡ï¼Œæ€»æ˜¯å‘é€æ–°è¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `â„¹ï¸ @${commenter}, éƒ¨ç½²å‘½ä»¤ä»…é€‚ç”¨äºç›®æ ‡ä¸º \`master\` åˆ†æ”¯çš„ PRã€‚æ­¤ PR (#${prNumber}) çš„ç›®æ ‡æ˜¯ \`${pr.base.ref}\`ã€‚`
              });
              core.setFailed('PR æœªä»¥ master ä¸ºç›®æ ‡ã€‚');
              return;
            }

            let comment_id_output = '';
            if (pr.merged && pr.state === 'closed') {
              const body = `âœ… @${commenter}, PR #${prNumber} å·²åˆå¹¶åˆ° masterã€‚å°†ç«‹å³å¼€å§‹éƒ¨ç½² master åˆ†æ”¯...`;
              comment_id_output = await findAndUpdateOrCreateComment(github, context, prNumber, marker, body, 'æŸ¥çœ‹ Workflow åˆå§‹çŠ¶æ€');
              core.setOutput('deploy_now', 'true');
            } else if (pr.state === 'open') {
              await github.rest.issues.addLabels({ // Add label first
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['deploy-when-merged']
              });
              const body = `â³ @${commenter}, å·²æ”¶åˆ°éƒ¨ç½² PR #${prNumber} çš„å‘½ä»¤ã€‚ç³»ç»Ÿå°†åœ¨ PR åˆå¹¶åˆ° master åè‡ªåŠ¨éƒ¨ç½²ã€‚æ ‡ç­¾ 'deploy-when-merged' å·²æ·»åŠ ã€‚`;
              comment_id_output = await findAndUpdateOrCreateComment(github, context, prNumber, marker, body, 'æŸ¥çœ‹ Workflow çŠ¶æ€');
              core.setOutput('deploy_now', 'false');
            } else { // PR å·²å…³é—­ä½†æœªåˆå¹¶
              // å¯¹äºå·²å…³é—­ä½†æœªåˆå¹¶çš„æƒ…å†µï¼Œæ€»æ˜¯å‘é€æ–°è¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `â„¹ï¸ @${commenter}, PR #${prNumber} å·²å…³é—­ä½†æœªåˆå¹¶åˆ° masterã€‚æ— æ³•éƒ¨ç½²ã€‚`
              });
              core.setFailed('PR å·²å…³é—­ä¸”æœªåˆå¹¶ã€‚');
              return;
            }
            // core.setOutput('comment_id', comment_id_output); // Output comment_id if needed by other steps directly

  # Job 2: å¦‚æœ 'deploy' è¯„è®ºåœ¨å·²åˆå¹¶çš„ PR ä¸Šï¼Œåˆ™ç«‹å³éƒ¨ç½² master
  deploy_master_immediately:
    needs: handle_deploy_comment
    if: success() && needs.handle_deploy_comment.outputs.should_deploy_immediately == 'true'
    runs-on: [self-hosted, website]
    steps:
      - name: Update Deployment Status (Immediate - In Progress)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt('${{ needs.handle_deploy_comment.outputs.pr_number_for_immediate_deploy }}');
            const commenter = '${{ needs.handle_deploy_comment.outputs.commenter_login }}';
            const marker = `<!-- GHA-DEPLOY-STATUS-PR#${prNumber} -->`;
            const workflowRunUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            async function findAndUpdateComment(github, context, issueNumber, marker, newBody, workflowLinkText) {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });
              const existingComment = comments.find(comment => comment.body && comment.body.includes(marker));
              
              let finalBody = newBody;
              if (workflowLinkText) {
                finalBody += `\n[${workflowLinkText}](${workflowRunUrl})`;
              }
              finalBody += `\n\n${marker}`; 

              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: finalBody,
                });
              } else { // Should ideally not happen if handle_deploy_comment created it
                console.warn(`Could not find comment to update for PR #${issueNumber} with marker. This might indicate an issue or a new comment will be created by a later step if it uses findOrCreate.`);
                // Optionally, create a new one here if absolutely necessary, but success/failure steps will do findOrCreate
              }
            }
            const body = `ğŸš€ @${commenter}ï¼Œæ­£åœ¨ç«‹å³éƒ¨ç½² master åˆ†æ”¯ (å›  PR #${prNumber} å·²åˆå¹¶)...`;
            await findAndUpdateComment(github, context, prNumber, marker, body, 'æŸ¥çœ‹ Workflow è¿è¡Œæƒ…å†µ');
      
      - name: Deploy Master Branch (Immediate)
        shell: bash
        env:
          PR_NUMBER: ${{ needs.handle_deploy_comment.outputs.pr_number_for_immediate_deploy }}
        run: |
          sudo echo "PR #${PR_NUMBER} (å·²åˆå¹¶) è§¦å‘ç«‹å³éƒ¨ç½² master åˆ†æ”¯..."
          # ... (rest of your deployment script) ...
          sudo echo "å¯¼èˆªåˆ° /var/www/voidix..."
          cd /var/www/voidix
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šæ— æ³•è¿›å…¥ç›®å½• /var/www/voidixã€‚"; exit 1; fi
          
          sudo echo "ä» origin æ‹‰å– master åˆ†æ”¯çš„æœ€æ–°æ›´æ”¹ (ä½¿ç”¨ sudo)..."
          sudo git fetch origin master
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šsudo git fetch origin master å¤±è´¥ã€‚"; exit 1; fi
          
          sudo echo "æ£€å‡ºå¹¶å°†æœ¬åœ° master åˆ†æ”¯é‡ç½®ä¸º origin/master (ä½¿ç”¨ sudo)..."
          sudo git checkout -B master origin/master
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šsudo git checkout -B master origin/master å¤±è´¥ã€‚"; exit 1; fi
          sudo echo "æˆåŠŸå°† /var/www/voidix æ›´æ–°åˆ° master åˆ†æ”¯çš„æœ€æ–°æäº¤ã€‚"
          
          sudo echo "é‡æ–°åŠ è½½ Nginx..."
          sudo systemctl reload nginx
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šé‡æ–°åŠ è½½ Nginx å¤±è´¥ã€‚è¯·æ£€æŸ¥ sudo æƒé™ã€‚"; exit 1; fi
          sudo echo "Nginx å·²æˆåŠŸé‡æ–°åŠ è½½ã€‚Master åˆ†æ”¯å·²éƒ¨ç½²å®Œæ¯•ã€‚"

      - name: Update Deployment Status (Immediate - Result)
        if: always() # Run whether deploy step succeeded or failed
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt('${{ needs.handle_deploy_comment.outputs.pr_number_for_immediate_deploy }}');
            const commenter = '${{ needs.handle_deploy_comment.outputs.commenter_login }}';
            const marker = `<!-- GHA-DEPLOY-STATUS-PR#${prNumber} -->`;
            const jobStatus = '${{ job.status }}';
            const workflowRunUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            let body = '';

            if (jobStatus === 'success') {
              body = `ğŸ‰ @${commenter}ï¼Œç«‹å³éƒ¨ç½²æˆåŠŸï¼master åˆ†æ”¯å·²æ›´æ–° (å›  PR #${prNumber} åˆå¹¶)ã€‚`;
            } else {
              body = `ğŸ”¥ @${commenter}ï¼Œç«‹å³éƒ¨ç½²å¤±è´¥ï¼åœ¨æ›´æ–° master åˆ†æ”¯æ—¶å‘ç”Ÿé”™è¯¯ (å›  PR #${prNumber} åˆå¹¶)ã€‚`;
            }

            async function findAndUpdateOrCreateComment(github, context, issueNumber, marker, newBody, workflowLinkText) {
              // (Re-define or ensure it's available - for brevity, assuming it's defined as in previous steps)
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });
              const existingComment = comments.find(comment => comment.body && comment.body.includes(marker));
              let finalBody = newBody;
              if (workflowLinkText) { finalBody += `\n[${workflowLinkText}](${workflowRunUrl})`; }
              finalBody += `\n\n${marker}`;
              if (existingComment) {
                await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: existingComment.id, body: finalBody });
              } else {
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber, body: finalBody });
              }
            }
            await findAndUpdateOrCreateComment(github, context, prNumber, marker, body, 'æŸ¥çœ‹ Workflow è¿è¡Œæ—¥å¿—');

  # Job 3: å¦‚æœå¸¦æœ‰ 'deploy-when-merged' æ ‡ç­¾çš„ PR åˆå¹¶åˆ° masterï¼Œåˆ™éƒ¨ç½² master
  deploy_on_merge_if_labelled:
    if: github.event_name == 'pull_request_target' && github.event.action == 'closed' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'master' && contains(join(github.event.pull_request.labels.*.name, ','), 'deploy-when-merged')
    runs-on: [self-hosted, website]
    steps:
      - name: Update Deployment Status (Merge - In Progress)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ github.event.pull_request.number }};
            const marker = `<!-- GHA-DEPLOY-STATUS-PR#${prNumber} -->`;
            const workflowRunUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const body = `ğŸš€ PR #${prNumber} å·²åˆå¹¶åˆ° master ä¸”å¸¦æœ‰ 'deploy-when-merged' æ ‡ç­¾ã€‚å¼€å§‹éƒ¨ç½² master åˆ†æ”¯...`;

            async function findAndUpdateOrCreateComment(github, context, issueNumber, marker, newBody, workflowLinkText) {
              // (Re-define or ensure it's available)
              const { data: comments } = await github.rest.issues.listComments({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber });
              const existingComment = comments.find(comment => comment.body && comment.body.includes(marker));
              let finalBody = newBody;
              if (workflowLinkText) { finalBody += `\n[${workflowLinkText}](${workflowRunUrl})`; }
              finalBody += `\n\n${marker}`;
              if (existingComment) {
                await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: existingComment.id, body: finalBody });
              } else {
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber, body: finalBody });
              }
            }
            await findAndUpdateOrCreateComment(github, context, prNumber, marker, body, 'æŸ¥çœ‹ Workflow è¿è¡Œæƒ…å†µ');

      - name: Deploy Master Branch (On Merge with Label)
        shell: bash
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          sudo echo "PR #${PR_NUMBER} (åˆå¹¶ä¸”å¸¦æ ‡ç­¾) è§¦å‘éƒ¨ç½² master åˆ†æ”¯..."
          # ... (rest of your deployment script) ...
          sudo echo "å¯¼èˆªåˆ° /var/www/voidix..."
          cd /var/www/voidix
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šæ— æ³•è¿›å…¥ç›®å½• /var/www/voidixã€‚"; exit 1; fi

          sudo echo "ä» origin æ‹‰å– master åˆ†æ”¯çš„æœ€æ–°æ›´æ”¹ (ä½¿ç”¨ sudo)..."
          sudo git fetch origin master
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šsudo git fetch origin master å¤±è´¥ã€‚"; exit 1; fi

          sudo echo "æ£€å‡ºå¹¶å°†æœ¬åœ° master åˆ†æ”¯é‡ç½®ä¸º origin/master (ä½¿ç”¨ sudo)..."
          sudo git checkout -B master origin/master
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šsudo git checkout -B master origin/master å¤±è´¥ã€‚"; exit 1; fi
          sudo echo "æˆåŠŸå°† /var/www/voidix æ›´æ–°åˆ° master åˆ†æ”¯çš„æœ€æ–°æäº¤ã€‚"

          sudo echo "é‡æ–°åŠ è½½ Nginx..."
          sudo systemctl reload nginx
          if [ $? -ne 0 ]; then sudo echo "é”™è¯¯ï¼šé‡æ–°åŠ è½½ Nginx å¤±è´¥ã€‚è¯·æ£€æŸ¥ sudo æƒé™ã€‚"; exit 1; fi
          sudo echo "Nginx å·²æˆåŠŸé‡æ–°åŠ è½½ã€‚Master åˆ†æ”¯å·²éƒ¨ç½²å®Œæ¯•ã€‚"

      - name: Update Deployment Status (Merge - Result) and Remove Label
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ github.event.pull_request.number }};
            const marker = `<!-- GHA-DEPLOY-STATUS-PR#${prNumber} -->`;
            const jobStatus = '${{ job.status }}';
            const workflowRunUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            let body = '';
            let labelRemovedText = "";

            if (jobStatus === 'success') {
              body = `ğŸ‰ éƒ¨ç½²æˆåŠŸï¼PR #${prNumber} åˆå¹¶åˆ° master çš„æ›´æ”¹å·²éƒ¨ç½²ã€‚`;
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'deploy-when-merged'
                });
                labelRemovedText = "\næ ‡ç­¾ 'deploy-when-merged' å·²ç§»é™¤ã€‚";
              } catch (error) {
                console.error(`ç§»é™¤æ ‡ç­¾ 'deploy-when-merged' å¤±è´¥: ${error.message}`);
                labelRemovedText = "\nå°è¯•ç§»é™¤æ ‡ç­¾ 'deploy-when-merged' å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥ã€‚";
              }
            } else {
              body = `ğŸ”¥ éƒ¨ç½²å¤±è´¥ï¼åœ¨éƒ¨ç½² PR #${prNumber} åˆå¹¶åˆ° master çš„æ›´æ”¹æ—¶å‘ç”Ÿé”™è¯¯ã€‚æ ‡ç­¾ 'deploy-when-merged' å¯èƒ½ä»ç„¶å­˜åœ¨ã€‚`;
            }
            body += labelRemovedText;

            async function findAndUpdateOrCreateComment(github, context, issueNumber, marker, newBody, workflowLinkText) {
              // (Re-define or ensure it's available)
              const { data: comments } = await github.rest.issues.listComments({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber });
              const existingComment = comments.find(comment => comment.body && comment.body.includes(marker));
              let finalBody = newBody;
              if (workflowLinkText) { finalBody += `\n[${workflowLinkText}](${workflowRunUrl})`; }
              finalBody += `\n\n${marker}`;
              if (existingComment) {
                await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: existingComment.id, body: finalBody });
              } else {
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber, body: finalBody });
              }
            }
            await findAndUpdateOrCreateComment(github, context, prNumber, marker, body, 'æŸ¥çœ‹ Workflow è¿è¡Œæ—¥å¿—'); 